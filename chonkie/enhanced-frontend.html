<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chonkie Text Chunker - Enhanced</title>
    <style>
        :root {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f8fafc;
            --border-color: #e2e8f0;
            --text-primary: #1e293b;
            --text-secondary: #374151;
            --text-muted: #64748b;
        }

        [data-theme="dark"] {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --border-color: #475569;
            --text-primary: #f1f5f9;
            --text-secondary: #e2e8f0;
            --text-muted: #94a3b8;
        }

        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 20px; 
            background: var(--bg-primary); 
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
        }
        .header { text-align: center; margin-bottom: 30px; position: relative; }
        .dark-mode-toggle { 
            position: absolute; 
            top: 0; 
            right: 0; 
            background: var(--bg-secondary); 
            border: 2px solid var(--border-color); 
            color: var(--text-primary); 
            padding: 8px 12px; 
            border-radius: 8px; 
            cursor: pointer; 
            font-size: 14px; 
            transition: all 0.2s;
        }
        .dark-mode-toggle:hover { 
            background: var(--bg-tertiary); 
            transform: scale(1.05); 
        }
        .container { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; }
        .section { background: var(--bg-secondary); border: 1px solid var(--border-color); padding: 25px; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: background-color 0.3s, border-color 0.3s; }
        .config-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .config-full { grid-column: 1 / -1; }
        textarea { width: 100%; height: 200px; margin-bottom: 15px; border: 2px solid var(--border-color); border-radius: 8px; padding: 12px; font-size: 14px; background: var(--bg-secondary); color: var(--text-primary); transition: all 0.3s; }
        textarea:focus { outline: none; border-color: #3b82f6; }
        button { background: linear-gradient(135deg, #3b82f6, #1d4ed8); color: white; padding: 12px 24px; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 16px; transition: all 0.2s; }
        button:hover { transform: translateY(-1px); box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3); }
        button:disabled { background: #94a3b8; cursor: not-allowed; transform: none; }
        .chunk { margin: 12px 0; padding: 15px; border: 2px solid #e2e8f0; border-radius: 8px; background: #f8fafc; transition: all 0.2s; }
        .chunk:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .chunk-header { font-weight: 600; margin-bottom: 8px; color: #1e293b; display: flex; justify-between; align-items: center; }
        .chunk-meta { font-size: 12px; color: #64748b; }
        select, input[type="range"], input[type="number"] { width: 100%; margin: 8px 0; padding: 8px; border: 2px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); transition: all 0.3s; }
        select:focus, input:focus { outline: none; border-color: #3b82f6; }
        label { display: block; margin: 15px 0 5px; font-weight: 500; color: #374151; }
        .range-container { display: flex; align-items: center; gap: 10px; }
        .range-value { min-width: 50px; text-align: center; font-weight: 600; color: #1e293b; }
        .advanced-toggle { background: #f1f5f9; border: 1px solid #cbd5e1; color: #475569; padding: 8px 16px; margin: 10px 0; font-size: 14px; }
        .advanced-options { display: none; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 20px; margin: 15px 0; }
        .advanced-options.visible { display: block; }
        .help-text { font-size: 12px; color: #64748b; margin-top: 4px; font-style: italic; }
        .chunker-tag { font-size: 10px; background: #dbeafe; color: #1e40af; padding: 2px 6px; border-radius: 4px; margin-left: 8px; }
        .loading { display: none; align-items: center; gap: 10px; color: #3b82f6; }
        .loading.visible { display: flex; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .spinner { width: 20px; height: 20px; border: 2px solid #e2e8f0; border-top: 2px solid #3b82f6; border-radius: 50%; animation: spin 1s linear infinite; }
        .error { background: #fef2f2; border: 1px solid #fecaca; color: #dc2626; padding: 12px; border-radius: 6px; margin: 10px 0; }
        .stats { background: #f0f9ff; border: 1px solid #bae6fd; padding: 12px; border-radius: 6px; margin: 15px 0; }
        
        /* Tab Styles */
        .input-tabs { display: flex; gap: 2px; margin-bottom: 15px; }
        .tab-button { 
            flex: 1; 
            padding: 10px 16px; 
            border: 2px solid var(--border-color); 
            background: var(--bg-tertiary); 
            color: var(--text-secondary); 
            border-radius: 8px 8px 0 0; 
            cursor: pointer; 
            font-size: 14px; 
            font-weight: 500;
            transition: all 0.2s;
        }
        .tab-button:hover { background: var(--bg-secondary); }
        .tab-button.active { 
            background: var(--bg-secondary); 
            color: var(--text-primary); 
            border-bottom-color: var(--bg-secondary); 
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        /* File Upload Styles */
        .file-info { 
            background: var(--bg-tertiary); 
            border: 1px solid var(--border-color); 
            border-radius: 6px; 
            padding: 10px; 
            margin: 10px 0; 
        }
        .upload-controls label { 
            display: flex; 
            align-items: center; 
            gap: 8px; 
            margin: 5px 0; 
            font-size: 14px; 
        }
        input[type="file"] { 
            padding: 10px; 
            border: 2px dashed var(--border-color); 
            border-radius: 8px; 
            background: var(--bg-tertiary); 
            transition: all 0.3s; 
        }
        input[type="file"]:hover { border-color: #3b82f6; }
        
        /* Cancel Button */
        .cancel-button { 
            background: linear-gradient(135deg, #ef4444, #dc2626); 
            margin-left: 10px; 
        }
        .cancel-button:hover { 
            box-shadow: 0 4px 8px rgba(239, 68, 68, 0.3); 
        }
    </style>
</head>
<body>
    <div class="header">
        <button class="dark-mode-toggle" onclick="toggleDarkMode()" id="darkModeToggle">
            üåô Dark Mode
        </button>
        <h1>üöÄ Chonkie Text Chunker - Enhanced</h1>
        <p>Advanced text chunking with full Chonkie library support</p>
    </div>
    
    <div class="container">
        <div class="section">
            <h2>üìù Input & Configuration</h2>
            
            <!-- Input Tabs -->
            <div class="input-tabs">
                <button type="button" class="tab-button active" onclick="switchTab('text')">‚úèÔ∏è Text Input</button>
                <button type="button" class="tab-button" onclick="switchTab('file')">üìÑ File Upload</button>
            </div>
            
            <!-- Text Input Tab -->
            <div id="text-tab" class="tab-content active">
                <label for="text">Text to chunk:</label>
                <textarea id="text" placeholder="Enter your text here...">This is a sample document for testing advanced text chunking capabilities. It contains multiple sentences across several paragraphs. The Chonkie library will split this text into manageable chunks based on the selected strategy. Each chunk will maintain semantic coherence while respecting the specified size limits. Advanced chunkers can use neural networks or large language models for more sophisticated splitting strategies.</textarea>
            </div>
            
            <!-- File Upload Tab -->
            <div id="file-tab" class="tab-content">
                <label for="file">Upload document:</label>
                <input type="file" id="file" accept=".txt,.md,.json,.csv,.xml,.html" onchange="handleFileUpload(event)">
                <div class="file-info" id="fileInfo" style="display: none;">
                    <div class="help-text" id="fileDetails"></div>
                    <div class="help-text" id="fileLimits"></div>
                </div>
                <div class="upload-controls" style="margin-top: 10px;">
                    <label>
                        <input type="checkbox" id="overrideLimit"> Override character limit 
                        <span style="color: #f59e0b;">‚ö†Ô∏è (May cause performance issues)</span>
                    </label>
                </div>
            </div>
            
            <div class="config-grid">
                <div>
                    <label for="chunkerType">Chunker Type:</label>
                    <select id="chunkerType" onchange="updateChunkerOptions()">
                        <option value="TokenChunker">Token Chunker</option>
                        <option value="SentenceChunker" selected>Sentence Chunker</option>
                        <option value="RecursiveChunker">Recursive Chunker</option>
                        <option value="SemanticChunker">Semantic Chunker <span class="chunker-tag">EMBEDDINGS</span></option>
                        <option value="CodeChunker">Code Chunker</option>
                        <option value="NeuralChunker">Neural Chunker <span class="chunker-tag">AI</span></option>
                        <option value="LateChunker">Late Chunker <span class="chunker-tag">EMBEDDINGS</span></option>
                        <option value="SlumberChunker">Slumber Chunker <span class="chunker-tag">LLM</span></option>
                    </select>
                    <div class="help-text" id="chunkerHelp">Splits text into chunks based on sentences</div>
                </div>
                
                <div>
                    <label for="tokenizerType">Tokenizer Type:</label>
                    <select id="tokenizerType">
                        <option value="CharacterTokenizer" selected>Character Tokenizer</option>
                        <option value="WordTokenizer">Word Tokenizer</option>
                    </select>
                </div>
            </div>
            
            <div class="config-grid">
                <div>
                    <label for="chunkSize">Chunk Size:</label>
                    <div class="range-container">
                        <input type="range" id="chunkSize" min="10" max="500" value="100" step="10">
                        <span class="range-value" id="chunkSizeValue">100</span>
                    </div>
                </div>
                
                <div>
                    <label for="chunkOverlap">Chunk Overlap:</label>
                    <div class="range-container">
                        <input type="range" id="chunkOverlap" min="0" max="100" value="20" step="5">
                        <span class="range-value" id="chunkOverlapValue">20</span>
                    </div>
                </div>
            </div>
            
            <button class="advanced-toggle" onclick="toggleAdvanced()">‚öôÔ∏è Advanced Options</button>
            
            <div class="advanced-options" id="advancedOptions">
                <div class="config-grid">
                    <div>
                        <label for="embeddingProvider">Embedding Provider:</label>
                        <select id="embeddingProvider" onchange="updateModelOptions()">
                            <option value="sentence-transformers" selected>Sentence Transformers (Local)</option>
                            <option value="openai">OpenAI Embeddings</option>
                            <option value="cohere">Cohere Embeddings</option>
                            <option value="gemini">Google Gemini</option>
                            <option value="jina">Jina AI</option>
                            <option value="voyage">Voyage AI</option>
                        </select>
                    </div>
                    
                    <div>
                        <label for="embeddingModel">Embedding Model:</label>
                        <select id="embeddingModel">
                            <option value="all-MiniLM-L6-v2" selected>all-MiniLM-L6-v2</option>
                            <option value="all-mpnet-base-v2">all-mpnet-base-v2</option>
                            <option value="multi-qa-MiniLM-L6-cos-v1">multi-qa-MiniLM-L6-cos-v1</option>
                        </select>
                    </div>
                </div>
                
                <div class="config-grid">
                    <div>
                        <label for="semanticThreshold">Semantic Threshold:</label>
                        <div class="range-container">
                            <input type="range" id="semanticThreshold" min="0" max="1" value="0.3" step="0.1">
                            <span class="range-value" id="semanticThresholdValue">0.3</span>
                        </div>
                        <div class="help-text">Lower values create more chunks, higher values create fewer chunks</div>
                    </div>
                    
                    <div>
                        <label for="similarityWindow">Similarity Window:</label>
                        <div class="range-container">
                            <input type="range" id="similarityWindow" min="1" max="10" value="3" step="1">
                            <span class="range-value" id="similarityWindowValue">3</span>
                        </div>
                        <div class="help-text">Number of sentences to compare for similarity</div>
                    </div>
                </div>
                
                <div class="config-grid" id="semanticAdvancedParams">
                    <div>
                        <label for="minSentencesPerChunk">Min Sentences per Chunk:</label>
                        <div class="range-container">
                            <input type="range" id="minSentencesPerChunk" min="1" max="10" value="1" step="1">
                            <span class="range-value" id="minSentencesPerChunkValue">1</span>
                        </div>
                        <div class="help-text">Minimum sentences required in each chunk <span style="color: #f59e0b;">‚ö†Ô∏è (Beta - may not function)</span></div>
                    </div>
                    
                    <div>
                        <label for="minCharactersPerSentence">Min Characters per Sentence:</label>
                        <div class="range-container">
                            <input type="range" id="minCharactersPerSentence" min="5" max="100" value="24" step="5">
                            <span class="range-value" id="minCharactersPerSentenceValue">24</span>
                        </div>
                        <div class="help-text">Minimum sentence length to be considered valid <span style="color: #f59e0b;">‚ö†Ô∏è (Beta - may not function)</span></div>
                    </div>
                </div>
                
                <div class="config-grid" id="semanticDelimiterConfig">
                    <div>
                        <label for="includeDelim">Include Delimiter:</label>
                        <select id="includeDelim">
                            <option value="prev" selected>Previous (attach to preceding chunk)</option>
                            <option value="next">Next (attach to following chunk)</option>
                            <option value="">None (exclude delimiters)</option>
                        </select>
                        <div class="help-text">How to handle sentence delimiters in chunks</div>
                    </div>

                    <div>
                        <label for="language">Language (optional):</label>
                        <select id="language">
                            <option value="">Auto-detect</option>
                            <option value="en">English</option>
                            <option value="es">Spanish</option>
                            <option value="fr">French</option>
                            <option value="de">German</option>
                            <option value="it">Italian</option>
                            <option value="pt">Portuguese</option>
                            <option value="ru">Russian</option>
                            <option value="zh">Chinese</option>
                            <option value="ja">Japanese</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <!-- Configuration Management -->
            <div class="config-full" style="border-top: 1px solid var(--border-color); padding-top: 20px; margin-top: 15px;">
                <h3>üíæ Configuration Management</h3>
                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px;">
                    <select id="configSelect" style="flex: 1;">
                        <option value="">Select a saved configuration...</option>
                    </select>
                    <button type="button" onclick="loadConfiguration()" style="padding: 8px 12px; font-size: 14px;">üì• Load</button>
                    <button type="button" onclick="saveConfiguration()" style="padding: 8px 12px; font-size: 14px;">üíæ Save</button>
                    <button type="button" onclick="deleteConfiguration()" style="padding: 8px 12px; font-size: 14px; background: linear-gradient(135deg, #ef4444, #dc2626);">üóëÔ∏è Delete</button>
                </div>
                <div class="help-text">Save your current settings as a reusable configuration for batch processing.</div>
            </div>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <span>Processing chunks...</span>
            </div>
            
            <div style="display: flex; gap: 10px; align-items: center;">
                <button onclick="chunkTextWithCancellation()" id="chunkButton">üìä Analyze & Chunk Text</button>
                <button onclick="cancelProcessing()" id="cancelButton" class="cancel-button" style="display: none;">‚èπÔ∏è Cancel</button>
            </div>
        </div>
        
        <div class="section">
            <h2>üìä Results</h2>
            <div id="results">Configure your settings and click "Analyze & Chunk Text" to see results...</div>
        </div>
    </div>

    <script>
        const embeddingModels = {
            'sentence-transformers': ['all-MiniLM-L6-v2', 'all-mpnet-base-v2', 'multi-qa-MiniLM-L6-cos-v1', 'paraphrase-multilingual-MiniLM-L12-v2'],
            'openai': ['text-embedding-3-small', 'text-embedding-3-large', 'text-embedding-ada-002'],
            'cohere': ['embed-english-v3.0', 'embed-multilingual-v3.0'],
            'gemini': ['embedding-001'],
            'jina': ['jina-embeddings-v2-base-en'],
            'voyage': ['voyage-2']
        };

        const chunkerDescriptions = {
            'TokenChunker': 'Splits text into fixed-size token chunks',
            'SentenceChunker': 'Splits text into chunks based on sentences',
            'RecursiveChunker': 'Splits text hierarchically using customizable rules',
            'SemanticChunker': 'Splits text based on semantic similarity using embeddings',
            'CodeChunker': 'Splits code into structurally meaningful chunks',
            'NeuralChunker': 'Splits text using a neural model for intelligent chunking',
            'LateChunker': 'Embeds text first, then splits for better chunk embeddings',
            'SlumberChunker': 'Uses LLM to find semantically meaningful chunks (AgenticChunker)'
        };

        // Update range display values
        ['chunkSize', 'chunkOverlap', 'semanticThreshold', 'similarityWindow', 'minSentencesPerChunk', 'minCharactersPerSentence'].forEach(id => {
            const element = document.getElementById(id);
            const valueElement = document.getElementById(id + 'Value');
            if (element && valueElement) {
                element.oninput = function() {
                    valueElement.textContent = this.value;
                };
            }
        });

        function toggleAdvanced() {
            const options = document.getElementById('advancedOptions');
            const button = document.querySelector('.advanced-toggle');
            options.classList.toggle('visible');
            button.textContent = options.classList.contains('visible') ? 'üîº Hide Advanced Options' : '‚öôÔ∏è Advanced Options';
        }

        function updateChunkerOptions() {
            const chunkerType = document.getElementById('chunkerType').value;
            const helpText = document.getElementById('chunkerHelp');
            helpText.textContent = chunkerDescriptions[chunkerType];
            
            // Define which chunkers need which settings
            const needsEmbeddings = ['SemanticChunker', 'NeuralChunker', 'LateChunker'].includes(chunkerType);
            const needsTokenizer = ['TokenChunker', 'CodeChunker', 'SlumberChunker'].includes(chunkerType);
            const needsOverlap = ['TokenChunker', 'SentenceChunker'].includes(chunkerType);
            const needsThreshold = ['SemanticChunker'].includes(chunkerType);
            const needsLanguage = ['CodeChunker'].includes(chunkerType);
            
            // Get elements
            const tokenizerDiv = document.getElementById('tokenizerType').closest('div');
            const overlapDiv = document.getElementById('chunkOverlap').closest('div');
            const embeddingProviderDiv = document.getElementById('embeddingProvider').closest('div');
            const embeddingModelDiv = document.getElementById('embeddingModel').closest('div');
            const thresholdDiv = document.getElementById('semanticThreshold').closest('div');
            const languageDiv = document.getElementById('language').closest('div');
            
            // Update visibility and styling
            tokenizerDiv.style.opacity = needsTokenizer ? '1' : '0.3';
            tokenizerDiv.style.pointerEvents = needsTokenizer ? 'auto' : 'none';
            
            overlapDiv.style.opacity = needsOverlap ? '1' : '0.3';
            overlapDiv.style.pointerEvents = needsOverlap ? 'auto' : 'none';
            
            embeddingProviderDiv.style.opacity = needsEmbeddings ? '1' : '0.3';
            embeddingProviderDiv.style.pointerEvents = needsEmbeddings ? 'auto' : 'none';
            
            embeddingModelDiv.style.opacity = needsEmbeddings ? '1' : '0.3';
            embeddingModelDiv.style.pointerEvents = needsEmbeddings ? 'auto' : 'none';
            
            thresholdDiv.style.opacity = needsThreshold ? '1' : '0.3';
            thresholdDiv.style.pointerEvents = needsThreshold ? 'auto' : 'none';
            
            languageDiv.style.opacity = needsLanguage ? '1' : '0.3';
            languageDiv.style.pointerEvents = needsLanguage ? 'auto' : 'none';
            
            // Advanced SemanticChunker parameters visibility
            const semanticAdvancedParams = document.getElementById('semanticAdvancedParams');
            const semanticDelimiterConfig = document.getElementById('semanticDelimiterConfig');
            const similarityWindowDiv = document.getElementById('similarityWindow').closest('div');
            
            if (semanticAdvancedParams) {
                semanticAdvancedParams.style.opacity = needsThreshold ? '1' : '0.3';
                semanticAdvancedParams.style.pointerEvents = needsThreshold ? 'auto' : 'none';
            }
            
            if (semanticDelimiterConfig) {
                semanticDelimiterConfig.style.opacity = needsThreshold ? '1' : '0.3';
                semanticDelimiterConfig.style.pointerEvents = needsThreshold ? 'auto' : 'none';
            }
            
            if (similarityWindowDiv) {
                similarityWindowDiv.style.opacity = needsThreshold ? '1' : '0.3';
                similarityWindowDiv.style.pointerEvents = needsThreshold ? 'auto' : 'none';
            }
            
            // Update chunker-specific limits when chunker changes
            updateChunkerLimits();
            
            // Update file upload limits if file is loaded
            const fileInfo = document.getElementById('fileInfo');
            if (fileInfo && fileInfo.style.display !== 'none') {
                updateFileUploadLimits();
            }
            
            // Clear any existing error messages when chunker changes
            clearError();
        }

        function updateModelOptions() {
            const provider = document.getElementById('embeddingProvider').value;
            const modelSelect = document.getElementById('embeddingModel');
            
            modelSelect.innerHTML = '';
            (embeddingModels[provider] || ['all-MiniLM-L6-v2']).forEach(model => {
                const option = document.createElement('option');
                option.value = model;
                option.textContent = model;
                modelSelect.appendChild(option);
            });
        }

        async function chunkText() {
            const text = document.getElementById('text').value;
            const config = {
                chunkerType: document.getElementById('chunkerType').value,
                chunkSize: parseInt(document.getElementById('chunkSize').value),
                chunkOverlap: parseInt(document.getElementById('chunkOverlap').value),
                tokenizerType: document.getElementById('tokenizerType').value,
                embeddingProvider: document.getElementById('embeddingProvider').value,
                embeddingModel: document.getElementById('embeddingModel').value,
                semanticThreshold: parseFloat(document.getElementById('semanticThreshold').value),
                language: document.getElementById('language').value || null,
                // Advanced SemanticChunker parameters
                similarityWindow: parseInt(document.getElementById('similarityWindow').value),
                minSentencesPerChunk: parseInt(document.getElementById('minSentencesPerChunk').value),
                minCharactersPerSentence: parseInt(document.getElementById('minCharactersPerSentence').value),
                includeDelim: document.getElementById('includeDelim').value || null
            };

            if (!text.trim()) {
                showError('Please enter some text to chunk');
                return;
            }

            const chunkerType = config.chunkerType;
            const limit = chunkerLimits[chunkerType] || 25000;
            const override = document.getElementById('overrideLimit').checked;

            if (text.length > limit && !override) {
                showError(`Text is too long (${text.length.toLocaleString()} chars). Limit for ${chunkerType}: ${limit.toLocaleString()}. Check "Override character limit" to proceed.`);
                return;
            }

            const resultsDiv = document.getElementById('results');
            const loadingDiv = document.getElementById('loading');
            const button = document.getElementById('chunkButton');
            
            loadingDiv.classList.add('visible');
            button.disabled = true;
            resultsDiv.innerHTML = '';

            try {
                const startTime = Date.now();
                const response = await fetch('/api/chunk', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        text, 
                        config, 
                        override_limit: override 
                    })
                });

                const totalTime = Date.now() - startTime;

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail?.[0]?.msg || errorData.error || `HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                displayResults(data, totalTime);
                
            } catch (error) {
                showError(`Error: ${error.message}`);
            } finally {
                loadingDiv.classList.remove('visible');
                button.disabled = false;
            }
        }

        function displayResults(data, totalTime) {
            const resultsDiv = document.getElementById('results');
            
            const stats = `
                <div class="stats">
                    <strong>üìä Processing Statistics</strong><br>
                    Chunks Created: <strong>${data.total_chunks}</strong> | 
                    Processing Time: <strong>${data.processing_time.toFixed(2)}ms</strong> | 
                    Total Time: <strong>${totalTime}ms</strong><br>
                    Strategy: <strong>${data.config.chunkerType}</strong> | 
                    Chunk Size: <strong>${data.config.chunkSize}</strong> | 
                    Overlap: <strong>${data.config.chunkOverlap}</strong>
                </div>
            `;
            
            const chunks = data.chunks.map((chunk, index) => {
                const colors = ['#dbeafe', '#f3e8ff', '#fef3c7', '#d1fae5', '#fce7f3', '#e0f2fe', '#fed7d7', '#f0fff4'];
                const color = colors[index % colors.length];
                
                return `
                    <div class="chunk" style="background-color: ${color};">
                        <div class="chunk-header">
                            <span>Chunk ${index + 1}</span>
                            <span class="chunk-meta">${chunk.content.length} chars${chunk.token_count ? `, ${chunk.token_count} tokens` : ''}</span>
                        </div>
                        <div>${chunk.content.replace(/\n/g, '<br>')}</div>
                    </div>
                `;
            }).join('');
            
            resultsDiv.innerHTML = stats + chunks;
        }

        function showError(message) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `<div class="error">‚ùå ${message}</div>`;
        }

        function clearError() {
            const resultsDiv = document.getElementById('results');
            if (resultsDiv.innerHTML.includes('class="error"')) {
                resultsDiv.innerHTML = 'Configure your settings and click "Analyze & Chunk Text" to see results...';
            }
        }

        function toggleDarkMode() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            
            const toggle = document.getElementById('darkModeToggle');
            toggle.textContent = newTheme === 'dark' ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode';
        }

        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            
            const toggle = document.getElementById('darkModeToggle');
            toggle.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode';
        }

        // Tab Switching
        function switchTab(tabName) {
            // Remove active class from all tabs and buttons
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            
            // Add active class to selected tab and button
            document.getElementById(tabName + '-tab').classList.add('active');
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
        }

        // Character limits by chunker type
        const chunkerLimits = {
            'TokenChunker': 25000,
            'SentenceChunker': 25000,
            'RecursiveChunker': 15000,
            'SemanticChunker': 8000,
            'CodeChunker': 20000,
            'NeuralChunker': 5000,
            'LateChunker': 5000,
            'SlumberChunker': 3000
        };

        // File Upload Handler
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const fileInfo = document.getElementById('fileInfo');
            const fileDetails = document.getElementById('fileDetails');
            const fileLimits = document.getElementById('fileLimits');
            const chunkerType = document.getElementById('chunkerType').value;
            const limit = chunkerLimits[chunkerType] || 25000;

            fileDetails.innerHTML = `üìÅ ${file.name} (${(file.size / 1024).toFixed(1)} KB, ${file.type || 'text/plain'})`;
            fileLimits.innerHTML = `‚ö†Ô∏è Character limit for ${chunkerType}: ${limit.toLocaleString()}`;
            fileInfo.style.display = 'block';

            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                document.getElementById('text').value = text;
                updateFileUploadLimits();
                clearError(); // Clear any previous errors when new file is loaded
            };
            reader.readAsText(file);
        }

        // Process Cancellation
        let currentAbortController = null;

        async function chunkTextWithCancellation() {
            // Cancel any existing request
            if (currentAbortController) {
                currentAbortController.abort();
            }
            
            // Create new abort controller
            currentAbortController = new AbortController();
            
            const text = document.getElementById('text').value;
            const config = {
                chunkerType: document.getElementById('chunkerType').value,
                chunkSize: parseInt(document.getElementById('chunkSize').value),
                chunkOverlap: parseInt(document.getElementById('chunkOverlap').value),
                tokenizerType: document.getElementById('tokenizerType').value,
                embeddingProvider: document.getElementById('embeddingProvider').value,
                embeddingModel: document.getElementById('embeddingModel').value,
                semanticThreshold: parseFloat(document.getElementById('semanticThreshold').value),
                language: document.getElementById('language').value || null,
                similarityWindow: parseInt(document.getElementById('similarityWindow').value),
                minSentencesPerChunk: parseInt(document.getElementById('minSentencesPerChunk').value),
                minCharactersPerSentence: parseInt(document.getElementById('minCharactersPerSentence').value),
                includeDelim: document.getElementById('includeDelim').value || null
            };

            if (!text.trim()) {
                showError('Please enter some text to chunk');
                return;
            }

            const chunkerType = config.chunkerType;
            const limit = chunkerLimits[chunkerType] || 25000;
            const override = document.getElementById('overrideLimit').checked;

            if (text.length > limit && !override) {
                showError(`Text is too long (${text.length.toLocaleString()} chars). Limit for ${chunkerType}: ${limit.toLocaleString()}. Check "Override character limit" to proceed.`);
                return;
            }

            const resultsDiv = document.getElementById('results');
            const loadingDiv = document.getElementById('loading');
            const chunkButton = document.getElementById('chunkButton');
            const cancelButton = document.getElementById('cancelButton');
            
            loadingDiv.classList.add('visible');
            chunkButton.style.display = 'none';
            cancelButton.style.display = 'inline-block';
            resultsDiv.innerHTML = '';

            try {
                const startTime = Date.now();
                const response = await fetch('/api/chunk', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        text, 
                        config, 
                        override_limit: override 
                    }),
                    signal: currentAbortController.signal
                });

                const totalTime = Date.now() - startTime;

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                displayResults(data, totalTime);
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    showError('‚èπÔ∏è Processing cancelled by user');
                } else {
                    showError(`Error: ${error.message}`);
                }
            } finally {
                loadingDiv.classList.remove('visible');
                chunkButton.style.display = 'inline-block';
                cancelButton.style.display = 'none';
                currentAbortController = null;
            }
        }

        function cancelProcessing() {
            if (currentAbortController) {
                currentAbortController.abort();
            }
        }

        // Update chunker-specific limits when chunker type changes
        function updateChunkerLimits() {
            const chunkerType = document.getElementById('chunkerType').value;
            const limit = chunkerLimits[chunkerType] || 25000;
            const fileLimits = document.getElementById('fileLimits');
            
            if (fileLimits && fileLimits.style.display !== 'none') {
                fileLimits.innerHTML = `‚ö†Ô∏è Character limit for ${chunkerType}: ${limit.toLocaleString()}`;
            }
        }

        // Update file upload limits when chunker changes
        function updateFileUploadLimits() {
            const chunkerType = document.getElementById('chunkerType').value;
            const limit = chunkerLimits[chunkerType] || 25000;
            const fileLimits = document.getElementById('fileLimits');
            const text = document.getElementById('text').value;
            
            if (fileLimits) {
                let limitText = `‚ö†Ô∏è Character limit for ${chunkerType}: ${limit.toLocaleString()}`;
                if (text && text.length > limit) {
                    const override = document.getElementById('overrideLimit').checked;
                    if (override) {
                        limitText += ` <span style="color: #ef4444;">üìè Current text: ${text.length.toLocaleString()} chars (OVERRIDDEN)</span>`;
                    } else {
                        limitText += ` <span style="color: #ef4444;">üìè Current text: ${text.length.toLocaleString()} chars (EXCEEDS LIMIT)</span>`;
                    }
                }
                fileLimits.innerHTML = limitText;
            }
        }

        // Configuration Save/Load System
        function saveConfiguration() {
            const config = {
                chunkerType: document.getElementById('chunkerType').value,
                chunkSize: parseInt(document.getElementById('chunkSize').value),
                chunkOverlap: parseInt(document.getElementById('chunkOverlap').value),
                tokenizerType: document.getElementById('tokenizerType').value,
                embeddingProvider: document.getElementById('embeddingProvider').value,
                embeddingModel: document.getElementById('embeddingModel').value,
                semanticThreshold: parseFloat(document.getElementById('semanticThreshold').value),
                language: document.getElementById('language').value || null,
                similarityWindow: parseInt(document.getElementById('similarityWindow').value),
                minSentencesPerChunk: parseInt(document.getElementById('minSentencesPerChunk').value),
                minCharactersPerSentence: parseInt(document.getElementById('minCharactersPerSentence').value),
                includeDelim: document.getElementById('includeDelim').value || null
            };

            const name = prompt('Enter a name for this configuration:');
            if (name) {
                const configs = JSON.parse(localStorage.getItem('chunkieConfigs') || '{}');
                configs[name] = config;
                localStorage.setItem('chunkieConfigs', JSON.stringify(configs));
                updateConfigDropdown();
                alert('Configuration saved!');
            }
        }

        function loadConfiguration() {
            const name = document.getElementById('configSelect').value;
            if (!name) return;

            const configs = JSON.parse(localStorage.getItem('chunkieConfigs') || '{}');
            const config = configs[name];
            
            if (config) {
                Object.keys(config).forEach(key => {
                    const element = document.getElementById(key);
                    if (element) {
                        element.value = config[key];
                        // Trigger oninput for range sliders
                        if (element.type === 'range') {
                            element.oninput();
                        }
                    }
                });
                updateChunkerOptions();
                updateModelOptions();
                updateChunkerLimits();
                alert('Configuration loaded!');
            }
        }

        function deleteConfiguration() {
            const name = document.getElementById('configSelect').value;
            if (!name) return;

            if (confirm(`Delete configuration "${name}"?`)) {
                const configs = JSON.parse(localStorage.getItem('chunkieConfigs') || '{}');
                delete configs[name];
                localStorage.setItem('chunkieConfigs', JSON.stringify(configs));
                updateConfigDropdown();
                alert('Configuration deleted!');
            }
        }

        function updateConfigDropdown() {
            const configs = JSON.parse(localStorage.getItem('chunkieConfigs') || '{}');
            const select = document.getElementById('configSelect');
            
            if (select) {
                select.innerHTML = '<option value="">Select a saved configuration...</option>';
                Object.keys(configs).forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    select.appendChild(option);
                });
            }
        }

        // Initialize
        initializeTheme();
        updateChunkerOptions();
        updateModelOptions();
        updateConfigDropdown();
    </script>
</body>
</html>